package generator

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"github.com/yamakiller/velcro-go/utils/velcropb"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".pb.velcro.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// package
	g.P(fmt.Sprintf("// Code generated by %s %s. DO NOT EDIT.", velcropb.Name, velcropb.Version))
	g.P()
	g.P("package ", file.GoPackageName)

	// imports
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "fmt"})
	g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "github.com/yamakiller/velcro-pb"})

	// import guard
	g.P("var (")
	g.P("_ = fmt.Errorf")
	g.P("_ = velcropb.Skip ")
	g.P(")")

	var invalidVars []string
	for i, imps := 0, file.Desc.Imports(); i < imps.Len(); i++ {
		imp := imps.Get(i)
		impFile, ok := gen.FilesByPath[imp.Path()]
		if !ok || impFile.GoImportPath == file.GoImportPath || imp.IsWeak {
			continue
		}
		alias := g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: impFile.GoImportPath})
		alias = strings.TrimSuffix(alias, ".")
		impPath := imp.Path()
		fileAlias := strings.ReplaceAll(impPath[:len(impPath)-len(filepath.Ext(impPath))], "/", "_")
		invalidVars = append(invalidVars, fmt.Sprintf("var _ = %s.File_%s_proto", alias, fileAlias))
	}

	// body
	gv := newVelcroGen(gen, file)
	var ps []VelcroAPIGenerator

	var messages []*protogen.Message
	messages = append(messages, file.Messages...)
	for i := 0; i < len(messages); i++ {
		msg := messages[i]
		ps = append(ps, gv.NewMessage(msg))
		sort.Sort(sortFields(msg.Fields))
		for _, field := range msg.Fields {
			ps = append(ps, gv.NewField(field))
		}
		// append nest
		for _, nestMsg := range msg.Messages {
			if !nestMsg.Desc.IsMapEntry() {
				messages = append(messages, nestMsg)
			}
		}
		// FIXME: support it
		for _, nestEnum := range msg.Enums {
			_ = nestEnum
		}
	}

	// 构建 body
	for i := range ps {
		ps[i].GenRead(g)
	}
	for i := range ps {
		ps[i].GenWrite(g)
	}
	for i := range ps {
		ps[i].GenSize(g)
	}
	for i := range ps {
		ps[i].GenConst(g)
	}
	for i := range invalidVars {
		g.P(invalidVars[i])
	}
	return g
}

type VelcroAPIGenerator interface {
	GenRead(g *protogen.GeneratedFile)
	GenWrite(g *protogen.GeneratedFile)
	GenSize(g *protogen.GeneratedFile)
	GenConst(g *protogen.GeneratedFile)
}

func newVelcroGen(gen *protogen.Plugin, f *protogen.File) *velcroGen {
	return &velcroGen{gen: gen, f: f}
}

func (v *velcroGen) NewMessage(m *protogen.Message) VelcroAPIGenerator {
	return &vgMessage{m: m}
}

type velcroGen struct {
	gen *protogen.Plugin
	f   *protogen.File
}

func (vg *velcroGen) NewField(f *protogen.Field) VelcroAPIGenerator {
	field := &vgField{}
	field.number = fmt.Sprintf("%d", f.Desc.Number())
	// explicit oneof
	if f.Oneof != nil && !f.Oneof.Desc.IsSynthetic() {
		field.oneofType = f.GoIdent.GoName
	}
	field.f = f
	field.isPointer = isPointer(f)
	field.body = vg.newFieldBody(f, f.Desc, f.Desc.IsList())
	return field

}

func (vg *velcroGen) newFieldBody(f *protogen.Field, desc protoreflect.FieldDescriptor, isList bool) velcroAPIBodyGenerator {
	isPointer := isPointer(f)
	// map
	if desc.IsMap() {
		// map
		b := &bodyMap{}
		k, v := desc.MapKey(), desc.MapValue()
		b.Key, b.Value = vg.newFieldBody(f, k, false), vg.newFieldBody(f, v, false)
		b.TypeName = fmt.Sprintf("map[%s]%s", b.Key.typeName(), b.Value.typeName())
		return b
	}
	// []
	if isList {
		b := &bodyList{}
		b.IsPacked = desc.IsPacked()
		b.Element = vg.newFieldBody(f, desc, false)
		b.TypeName = "[]" + b.Element.typeName()
		return b
	}
	// Enum
	kind := desc.Kind()
	switch kind {
	case protoreflect.MessageKind:
		// *struct
		b := &bodyMessage{}
		// FIXME: Any is unsupported.
		b.TypeName = "*" + parseTypeName(desc.Message(), vg.f.Proto)
		return b
	case protoreflect.EnumKind:
		// Enum
		b := &bodyEnum{}
		b.TypeName = parseTypeName(desc.Enum(), vg.f.Proto)
		b.IsOptional = isPointer
		return b
	default:
		b := &bodyBase{}
		b.TypeName = kindGoType[kind]
		b.APIType = kindAPIType[kind]
		b.IsPointer = isPointer
		return b
	}
}

var _ VelcroAPIGenerator = &vgMessage{}

type vgMessage struct {
	m *protogen.Message
}

func (v *vgMessage) name() string {
	return v.m.GoIdent.GoName
}

func (v *vgMessage) GenRead(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) Read(buf []byte, _type int8, number int32) (offset int, err error) {", v.name()))
	// switch case
	g.P("switch number {")
	for i := range v.m.Fields {
		number := v.m.Fields[i].Desc.Number()
		g.P(fmt.Sprintf("case %d:", number))
		g.P(fmt.Sprintf("offset, err = x.readField%d(buf, _type)", number))
		g.P("if err != nil { goto ReadFieldError }")
	}
	g.P(`default:`)
	g.P(`offset, err = velcropb.Skip(buf, _type, number)`)
	g.P(`if err != nil { goto SkipFieldError }`)
	g.P(`}`)
	// return
	g.P(`return offset, nil`)
	g.P(`SkipFieldError:`)
	g.P(`return offset, fmt.Errorf("%T cannot parse invalid wire-format data, error: %s", x, err)`)
	if len(v.m.Fields) > 0 {
		g.P(`ReadFieldError:`)
		g.P(`return offset, fmt.Errorf("%T read field %d '%s' error: %s", x, number, fieldIDToName_` + v.name() + `[number], err)`)
	}
	g.P(`}`)
	g.P()
}

func (f *vgMessage) GenWrite(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) Write(buf []byte) (offset int) {", f.name()))
	// switch case
	g.P("if x == nil { return offset }")
	for i := range f.m.Fields {
		number := f.m.Fields[i].Desc.Number()
		g.P(fmt.Sprintf("offset += x.writeField%d(buf[offset:])", number))
	}
	g.P(`return offset`)
	g.P(`}`)
	g.P()
}

func (f *vgMessage) GenSize(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) Size() (n int) {", f.name()))
	// switch case
	g.P("if x == nil { return n }")
	for i := range f.m.Fields {
		number := f.m.Fields[i].Desc.Number()
		g.P(fmt.Sprintf("n += x.sizeField%d()", number))
	}
	g.P(`return n`)
	g.P(`}`)
	g.P()
}

func (f *vgMessage) GenConst(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("var fieldIDToName_%s = map[int32]string {", f.name()))
	for _, field := range f.m.Fields {
		g.P(fmt.Sprintf(`%d: "%s",`, field.Desc.Number(), field.GoName))
	}
	g.P(`}`)
	g.P()
}

var _ VelcroAPIGenerator = &vgField{}

type vgField struct {
	f         *protogen.Field
	number    string // field number string
	oneofType string // field may is oneof
	body      velcroAPIBodyGenerator
	isPointer bool
}

func (v *vgField) parentName() string {
	return v.f.Parent.GoIdent.GoName
}

func (v *vgField) name() string {
	return v.f.GoName
}

// oneof shared name
func (v *vgField) oneofName() string {
	return v.f.Oneof.GoName
}

func (v *vgField) GenRead(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) readField%s(buf []byte, _type int8) (offset int, err error) {", v.parentName(), v.number))
	setter := fmt.Sprintf("x.%s", v.name())
	// oneof need replace setter
	if v.oneofType != "" {
		g.P(fmt.Sprintf("var ov %s", v.oneofType))
		g.P(fmt.Sprintf("x.%s = &ov", v.oneofName())) // oneof use shared name
		setter = fmt.Sprintf("ov.%s", v.name())
	}
	v.body.bodyRead(g, setter, v.f.Desc.IsList())
	g.P("}")
	g.P()
}

func (v *vgField) GenWrite(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) writeField%s(buf []byte) (offset int) {", v.parentName(), v.number))

	setter := fmt.Sprintf("x.%s", v.name())
	getSetter := fmt.Sprintf("x.Get%s()", v.name())
	// oneof need replace setter
	if v.oneofType != "" {
		setter = fmt.Sprintf("x.Get%s()", v.name())
	}
	switch {
	case v.f.Desc.Kind() == protoreflect.MessageKind, v.isPointer:
		g.P(fmt.Sprintf("if %s == nil { return offset }", setter))
	case v.f.Desc.IsMap() || v.f.Desc.IsList() || v.f.Desc.Kind() == protoreflect.BytesKind:
		g.P(fmt.Sprintf("if len(%s) == 0 { return offset }", setter))
	case v.f.Desc.Kind() == protoreflect.BoolKind:
		g.P(fmt.Sprintf("if !%s { return offset }", setter))
	case v.f.Desc.Kind() == protoreflect.StringKind:
		g.P(fmt.Sprintf(`if %s == "" { return offset }`, setter))
	default:
		g.P(fmt.Sprintf("if %s == 0 { return offset }", setter))
	}
	v.body.bodyWrite(g, getSetter, v.number)
	g.P("return offset")
	g.P("}")
	g.P()
}

func (v *vgField) GenSize(g *protogen.GeneratedFile) {
	g.P(fmt.Sprintf("func (x *%s) sizeField%s() (n int) {", v.parentName(), v.number))

	setter := fmt.Sprintf("x.%s", v.name())
	getSetter := fmt.Sprintf("x.Get%s()", v.name())
	// oneof need replace setter
	if v.oneofType != "" {
		setter = fmt.Sprintf("x.Get%s()", v.name())
	}
	switch {
	case v.f.Desc.Kind() == protoreflect.MessageKind, v.isPointer:
		g.P(fmt.Sprintf("if %s == nil { return n }", setter))
	case v.f.Desc.IsMap() || v.f.Desc.IsList() || v.f.Desc.Kind() == protoreflect.BytesKind:
		g.P(fmt.Sprintf("if len(%s) == 0 { return n }", setter))
	case v.f.Desc.Kind() == protoreflect.BoolKind:
		g.P(fmt.Sprintf("if !%s { return n }", setter))
	case v.f.Desc.Kind() == protoreflect.StringKind:
		g.P(fmt.Sprintf(`if %s == "" { return n }`, setter))
	default:
		g.P(fmt.Sprintf("if %s == 0 { return n }", setter))
	}
	v.body.bodySize(g, getSetter, v.number)
	g.P("return n")
	g.P("}")
	g.P()
}

func (v *vgField) GenConst(g *protogen.GeneratedFile) {}

type velcroAPIBodyGenerator interface {
	typeName() string
	bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool)
	bodyWrite(g *protogen.GeneratedFile, setter, number string)
	bodySize(g *protogen.GeneratedFile, setter, number string)
}

// no *struct here
type bodyBase struct {
	TypeName  string
	APIType   string
	IsPointer bool
}

func (f *bodyBase) typeName() string {
	return f.TypeName
}

func (f *bodyBase) bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool) {
	if !appendSetter {
		if f.IsPointer && f.APIType != "Bytes" {
			g.P(fmt.Sprintf("tmp, offset, err := velcropb.Read%s(buf, _type)", f.APIType))
			g.P(fmt.Sprintf("%s = &tmp", setter))
		} else {
			g.P(fmt.Sprintf("%s, offset, err = velcropb.Read%s(buf, _type)", setter, f.APIType))
		}
		g.P(`return offset, err`)
		return
	}
	// appendSetter
	g.P(fmt.Sprintf("var v %s", f.TypeName))
	if f.IsPointer {
		g.P(fmt.Sprintf("tmp, offset, err := velcropb.Read%s(buf, _type)", f.APIType))
		g.P(fmt.Sprintf("%s = &tmp", setter))
	} else {
		g.P(fmt.Sprintf("v, offset, err = velcropb.Read%s(buf, _type)", f.APIType))
	}
	g.P(`if err != nil { return offset, err }`)
	g.P(fmt.Sprintf("%s = append(%s, v)", setter, setter))
	g.P(`return offset, err`)
}

func (f *bodyBase) bodyWrite(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("offset += velcropb.Write%s(buf[offset:], %s, %s)", f.APIType, number, setter))
}

func (f *bodyBase) bodySize(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("n += velcropb.Size%s(%s, %s)", f.APIType, number, setter))
}

func isPointer(field *protogen.Field) (isPointer bool) {
	return field.Oneof != nil && field.Oneof.Desc.IsSynthetic()
}

// enum
type bodyEnum struct {
	TypeName   string
	IsOptional bool
}

func (f *bodyEnum) typeName() string {
	return f.TypeName
}

func (f *bodyEnum) bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool) {
	g.P("var v int32")
	g.P("v, offset, err = velcropb.ReadInt32(buf, _type)")
	g.P(`if err != nil { return offset, err }`)
	suffix := ""
	if f.IsOptional {
		suffix = ".Enum()"
	}
	if appendSetter {
		g.P(fmt.Sprintf("%s = append(%s, %s(v)%s)", setter, setter, f.TypeName, suffix))
	} else {
		g.P(fmt.Sprintf("%s = %s(v)%s", setter, f.TypeName, suffix))
	}
	g.P("return offset, nil")
}

func (f *bodyEnum) bodyWrite(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("offset += velcropb.WriteInt32(buf[offset:], %s, int32(%s))", number, setter))
}

func (f *bodyEnum) bodySize(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("n += velcropb.SizeInt32(%s, int32(%s))", number, setter))
}

// *struct
type bodyMessage struct {
	TypeName string
}

func (f *bodyMessage) typeName() string {
	return f.TypeName
}

func (f *bodyMessage) bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool) {
	g.P("var v ", f.TypeName[1:]) // type name is *struct, trim * here
	g.P("offset, err = velcropb.ReadMessage(buf, _type, &v)")
	g.P(`if err != nil { return offset, err }`)
	if appendSetter {
		g.P(fmt.Sprintf("%s = append(%s, &v)", setter, setter))
	} else {
		g.P(setter, " = &v")
	}
	g.P("return offset, nil")
}

func (f *bodyMessage) bodyWrite(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("offset += velcropb.WriteMessage(buf[offset:], %s, %s)", number, setter))
}

func (f *bodyMessage) bodySize(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("n += velcropb.SizeMessage(%s, %s)", number, setter))
}

// string, bytes, *struct, no packed map
type bodyList struct {
	TypeName string // []xxx
	IsPacked bool
	Element  velcroAPIBodyGenerator
}

func (f *bodyList) typeName() string {
	return f.TypeName
}

func (f *bodyList) bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool) {
	// packed
	if f.IsPacked {
		g.P(`offset, err = velcropb.ReadList(buf, _type,`)
		g.P(`func(buf []byte, _type int8) (n int, err error) {`)
		f.Element.bodyRead(g, setter, appendSetter)
		g.P(`})`)
		g.P(`return offset, err`)
		return
	}
	f.Element.bodyRead(g, setter, appendSetter)
}

func (f *bodyList) bodyWrite(g *protogen.GeneratedFile, setter, number string) {
	if f.IsPacked {
		g.P(fmt.Sprintf("offset += velcropb.WriteListPacked(buf[offset:], %s, len(%s),", number, setter))
		g.P(`func(buf []byte, numTagOrKey, numIdxOrVal int32) int {`)
		g.P(`offset := 0`)
		f.Element.bodyWrite(g, setter+"[numIdxOrVal]", "numTagOrKey")
		g.P(`return offset`)
		g.P(`})`)
		return
	}
	g.P(fmt.Sprintf("for i := range %s {", setter))
	f.Element.bodyWrite(g, setter+"[i]", number)
	g.P(`}`)
}

func (f *bodyList) bodySize(g *protogen.GeneratedFile, setter, number string) {
	if f.IsPacked {
		g.P(fmt.Sprintf("n += velcropb.SizeListPacked(%s, len(%s),", number, setter))
		g.P(`func(numTagOrKey, numIdxOrVal int32) int {`)
		g.P(`n := 0`)
		f.Element.bodySize(g, setter+"[numIdxOrVal]", "numTagOrKey")
		g.P(`return n`)
		g.P(`})`)
		return
	}
	g.P(fmt.Sprintf("for i := range %s {", setter))
	f.Element.bodySize(g, setter+"[i]", number)
	g.P(`}`)
}

// map cannot append, no []map list
type bodyMap struct {
	TypeName   string // map[xxx]xxx
	Key, Value velcroAPIBodyGenerator
}

func (f *bodyMap) typeName() string {
	return f.TypeName
}

func (f *bodyMap) bodyRead(g *protogen.GeneratedFile, setter string, appendSetter bool) {
	// check nil
	g.P(fmt.Sprintf(`if %s == nil { %s = make(%s) }`, setter, setter, f.typeName()))
	// set default
	g.P(fmt.Sprintf("var key %s", f.Key.typeName()))
	g.P(fmt.Sprintf("var value %s", f.Value.typeName()))
	// unmarshal
	g.P("offset, err = velcropb.ReadMapEntry(buf, _type,")
	g.P(`func(buf []byte, _type int8) (offset int, err error) {`)

	f.Key.bodyRead(g, "key", false)
	g.P(`},`)
	g.P(`func(buf []byte, _type int8) (offset int, err error) {`)
	f.Value.bodyRead(g, "value", false)
	g.P(`})`)

	g.P(`if err != nil { return offset, err }`)
	g.P(setter, "[key] = value")
	g.P("return offset, nil")
}

func (f *bodyMap) bodyWrite(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("for k, v := range %s {", setter))
	g.P(fmt.Sprintf("offset += velcropb.WriteMapEntry(buf[offset:], %s,", number))
	g.P(`func(buf []byte, numTagOrKey, numIdxOrVal int32) int {`)
	g.P(`offset := 0`)
	f.Key.bodyWrite(g, "k", "numTagOrKey")
	f.Value.bodyWrite(g, "v", "numIdxOrVal")
	g.P(`return offset`)
	g.P(`})`)
	g.P(`}`)
}

func (f *bodyMap) bodySize(g *protogen.GeneratedFile, setter, number string) {
	g.P(fmt.Sprintf("for k, v := range %s {", setter))
	g.P(fmt.Sprintf("n += velcropb.SizeMapEntry(%s,", number))
	g.P(`func(numTagOrKey, numIdxOrVal int32) int {`)
	g.P(`n := 0`)
	f.Key.bodySize(g, "k", "numTagOrKey")
	f.Value.bodySize(g, "v", "numIdxOrVal")
	g.P(`return n`)
	g.P(`})`)
	g.P(`}`)
}

var kindAPIType = []string{
	protoreflect.BoolKind:     "Bool",
	protoreflect.Int32Kind:    "Int32",
	protoreflect.Sint32Kind:   "Sint32",
	protoreflect.Uint32Kind:   "Uint32",
	protoreflect.Int64Kind:    "Int64",
	protoreflect.Sint64Kind:   "Sint64",
	protoreflect.Uint64Kind:   "Uint64",
	protoreflect.Sfixed32Kind: "Sfixed32",
	protoreflect.Fixed32Kind:  "Fixed32",
	protoreflect.FloatKind:    "Float",
	protoreflect.Sfixed64Kind: "Sfixed64",
	protoreflect.Fixed64Kind:  "Fixed64",
	protoreflect.DoubleKind:   "Double",
	protoreflect.StringKind:   "String",
	protoreflect.BytesKind:    "Bytes",
}

var kindGoType = []string{
	protoreflect.BoolKind:     "bool",
	protoreflect.Int32Kind:    "int32",
	protoreflect.Sint32Kind:   "int32",
	protoreflect.Uint32Kind:   "uint32",
	protoreflect.Int64Kind:    "int64",
	protoreflect.Sint64Kind:   "int64",
	protoreflect.Uint64Kind:   "uint64",
	protoreflect.Sfixed32Kind: "int32",
	protoreflect.Fixed32Kind:  "uint32",
	protoreflect.FloatKind:    "float32",
	protoreflect.Sfixed64Kind: "int64",
	protoreflect.Fixed64Kind:  "uint64",
	protoreflect.DoubleKind:   "float64",
	protoreflect.StringKind:   "string",
	protoreflect.BytesKind:    "[]byte",
}

type sortFields []*protogen.Field

func (s sortFields) Len() int {
	return len(s)
}

func (s sortFields) Less(i, j int) bool {
	return s[i].Desc.Number() < s[j].Desc.Number()
}

func (s sortFields) Swap(i, j int) {
	tmp := s[i]
	s[i] = s[j]
	s[j] = tmp
}

func parseTypeName(desc protoreflect.Descriptor, vdesc *descriptorpb.FileDescriptorProto) string {
	switch desc.Parent().(type) {
	case protoreflect.MessageDescriptor:
		fullname := string(desc.FullName())
		name := strings.TrimPrefix(fullname, string(desc.ParentFile().Package())+".")
		name = strings.ReplaceAll(name, ".", "_")
		return name
	default:
		// protoreflect.FileDescriptor usually
		name := strings.ReplaceAll(string(desc.Name()), ".", "_")
		pfo := desc.ParentFile().Options().(*descriptorpb.FileOptions)
		parentGoPkg := *pfo.GoPackage
		goPkg := string(*vdesc.Options.GoPackage)
		if parentGoPkg != goPkg {
			name = filepath.Base(parentGoPkg) + "." + name
		}
		return name
	}
}
